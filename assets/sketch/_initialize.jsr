class Scene extends THREE.Scene {
	constructor() {
	  super();
	  	// BETA:
		this.fog = new THREE.FogExp2(0xC5C9DB, 0.0003);
	  	this.background = new THREE.Color(0x87CEEB); // Blue-white sky color
	}
  }
  
  class Camera extends THREE.PerspectiveCamera {
	constructor() {
	  super(60, window.innerWidth / window.innerHeight, 0.1, 5000);
	}
  }
  
  class Renderer extends THREE.WebGLRenderer {
	constructor() {
		super({ antialias: true });
		this.shadowMap.autoUpdate = false;
		this.outputEncoding = THREE.sRGBEncoding;
		this.setSize(window.innerWidth, window.innerHeight);	  

		// BETA: 
		this.shadowMap.enabled = true;
		this.shadowMap.type = THREE.VSMShadowMap;
		// this.shadowMap.type = THREE.PCFSoftShadowMap;
		// this.setPixelRatio(1); // adjust render quality
	}
  }


  class DirectionalLight extends THREE.DirectionalLight {
	constructor() {
	super(0xffffff);
	this.shadow.camera.top = 500;
	this.shadow.camera.bottom = -500;
	this.shadow.camera.left = -500;
	this.shadow.camera.right = 500;
	this.shadow.camera.near = 1;
	this.shadow.camera.far = 5000;
	// BETA:
	this.shadow.mapSize.set(1024, 1024);
	this.shadow.bias = -0.001;
	
	this.position.set(100, 500, 600);
	this.target.position.set(0, 0, 0); // Position the target at the center of the world

	this.castShadow = true;
	this.shadow.camera.position.set(-500, 1000, -500); // Adjusted light angle

	// Create a box to visualize the shadow camera frustum
	const shadowCameraHelper = new THREE.CameraHelper(this.shadow.camera);
	this.add(shadowCameraHelper);
	}
}




class Cloud extends THREE.Object3D {
	constructor() {
	  super();
  
	  const cloudMaterial = new THREE.MeshLambertMaterial({
		color: 0xffffff,
		transparent: true,
		opacity: 0.13,
	  });
  
	  const numDodecahedrons = Math.floor(Math.random() * 2) + 4; // Random number of dodecahedrons (between 4 and 5)
	  const cloudSize = Math.random() * 32 + 26; // Random size between 50 and 80
  
	  const cloudGeometry = new THREE.DodecahedronGeometry(cloudSize, 0);
	  const cloudMesh = new THREE.InstancedMesh(cloudGeometry, cloudMaterial, numDodecahedrons);
  
	  for (let i = 0; i < numDodecahedrons; i++) {
		const x = Math.random() * 1500 - 750; // Random x position between -500 and 500
		const y = Math.random() * 150 + 130; // Random y position between 100 and 300
		const z = Math.random() * 1500 - 750; // Random z position between -500 and 500
  
		const scale = cloudSize / 50; // Adjust the scale based on the size
		const matrix = new THREE.Matrix4().compose(new THREE.Vector3(x, y, z), new THREE.Quaternion(), new THREE.Vector3(scale, scale, scale));
		cloudMesh.setMatrixAt(i, matrix);
	  }
  
	  this.add(cloudMesh);
	}
  }
  
  
  



  class Skydome extends THREE.Mesh {
	constructor() {
		const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
		const skyMaterial = new THREE.ShaderMaterial({
			vertexShader: `
				varying vec3 vWorldPosition;

				void main() {
					vec4 worldPosition = modelMatrix * vec4(position, 1.0);
					vWorldPosition = worldPosition.xyz;
					gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				}
			`,
			fragmentShader: `
				varying vec3 vWorldPosition;

				void main() {
					float brightness = clamp(vWorldPosition.y / 1000.0, 0.0, 1.0);
					
					// Calculate the gradient based on the vertical position
					float gradient = clamp((vWorldPosition.y + 500.0) / 1000.0, 0.0, 1.0);
					
					// Interpolate between a lighter blue and the bottom blue using the gradient
					vec3 topColor = vec3(0.8, 0.9, 1.0); // Lighter blue color
					vec3 bottomColor = vec3(0.53, 0.81, 0.92); // Bottom blue color
					vec3 skyColor = mix(topColor, bottomColor, gradient);

					gl_FragColor = vec4(skyColor, 1.0);
				}
			`,
			side: THREE.DoubleSide, // Disable backface culling
		});

		super(skyGeometry, skyMaterial);
	}
}


class World {
	constructor(scene, callback) {
		this.scene = scene;
		this.callback = callback;
		new _Loader().parse(_Model, '', this.onLoad, this.onError);
	}

	onLoad = (world) => {
		this.scene.add(world.scene);

		// Create a Box3 object to define the boundaries of the box
		const box = new THREE.Box3(
			new THREE.Vector3(-200, 0, -200), // Minimum corner of the box
			new THREE.Vector3(200, 800, 200)     // Maximum corner of the box
		);

		this.border = box;
	
		// Create a Box3Helper to generate a wireframe representation of the box
		const boxHelper = new THREE.Box3Helper(box, 0xffff00); // Yellow color
	
		// Add the Box3Helper to the world scene
		this.scene.add(boxHelper);

		/*
			Study_Shed_3
			Study_Shed_2
			Snack_Area
			Road
			PE_Building
			BLDG_F_-_Toilet
			BLDG_9_-_ICT_Building
			BLDG_6
			BLDG_54_-_FIC_Extension
			BLDG_53_-_Residences
			BLDG_52_Sump_Pit
			BLDG_5_-_Old_Engineering_Building
			BLDG_48_-_Fabrication_Laboratory
			BLDG_47_-_Technology_Building
			BLDG_45_-_Supply_Office
			BLDG_44_-_Student_Center_&_Education_Complex
			BLDG_4243_-__Engineering_Complex
			BLDG_41_Science_Complex
			BLDG_4_-_ROTC_Building
			BLDG_36_-_Old_Student_Center
			BLDG_35_-_Old_Education_Building
			BLDG_3_-_Integrated_Tehnology_Building
			BLDG_28_-_Old_Science_Buidling
			BLDG_27_-_Old_Medical_Building
			BLDG_26_-_Food_Innovation_Center
			BLDG_25_-_Food_Innovation_Center
			BLDG_24_-_Food_Trading_Building
			BLDG_23_-_Learning_Resource_Center
			BLDG_21_-_Guard_House
			BLDG_20_-_Cafeteria
			BLDG_19_Science_Centrum_Building
			BLDG_18_-_Culinary_Building
			BLDG_16_-_RER_Memorial_hall
			BLDG_1415_-_Finance_and_Accounting_BuildingHRM_Building
			BLDG_10_-_Administration_Building
			BLDG_1_-_Arts_and_Culture_Building
			Marker
			Marker001
			Marker002
			Marker003
			Marker004
			Marker005
			Marker006
			Marker007
			Marker008
			Marker009
			Marker010
			Marker011
			Marker012
			Marker013
			Marker014
			Marker015
			Marker016
			Marker017
			Marker018
			Marker019
			Marker020
			Marker021
			Marker022
			Marker023
			Marker024
			Marker025
			Marker026
			Marker027
			Trees
			Pathway001
			Study_Shed_4
			Study_Shed_1
		*/


		/** Filter Blacklist Mesh Of Model
			let meshGroup = world.scene.children;
			meshGroup = meshGroup.filter(mesh => {
				// don't include in renderer
				return mesh.name !== 'Trees';
			});
			world.scene.children = meshGroup;
		*/


		let meshGroup = world.scene.children;
		meshGroup = meshGroup.filter(mesh => {
		  // Exclude objects from casting shadows
		  return !mesh.name.startsWith('Marker');
		});
		world.scene.children = meshGroup;
		


		/** Show Polynomial Count of Model
			let totalPolygonCount = 0;

			world.scene.traverse((child) => {
			if (child instanceof THREE.Mesh) {
				// Access the position attribute of the mesh's geometry
				const positionAttribute = child.geometry.getAttribute('position');
		
				// Get the number of vertices in the mesh's geometry
				const vertexCount = positionAttribute.count;
		
				// Calculate the number of polygons (triangles) based on the number of vertices
				const polygonCount = vertexCount / 3;
		
				totalPolygonCount += polygonCount;
			}
			});

			console.log(`Polycount: ${totalPolygonCount}`);
		*/
	  

		// Add lights, clouds, and skydome
		this.addLights();
		this.addSkydome();

		// Prevent material reference duplication bug
		const cloneMaterial = (mesh) => mesh.material.clone();

		const noShadowCast = ['Road', 'Pathway001'];
		const noTransparency = ['Road', 'Pathway001', 'Trees'];

		let enableShaders = false;

		if (enableShaders) {
			for (let child of world.scene.children) {
				// console.log(child.type, child.name);
				if (child instanceof THREE.Group) {
					child.traverse((subchild) => {
						if (subchild instanceof THREE.Mesh) {
							subchild.receiveShadow = true;
							if (!noShadowCast.includes(child.name)) {
								subchild.castShadow = true;
							}
							// subchild.material = cloneMaterial(subchild);	
							if (!noTransparency.includes(child.name)) {
								subchild.material.transparent = true;
								subchild.material.opacity = 0.7;					
							}
						}
					});
				} 
				
				else if (child instanceof THREE.Mesh) {
					// Prevent material reference duplication bug
					child.receiveShadow = true;
					if (!noShadowCast.includes(child.name)) {
						child.castShadow = true;
					}
					// child.material = cloneMaterial(child);
					if (!noTransparency.includes(child.name)) {
						child.material.transparent = true;
						child.material.opacity = 0.7;
					}
				}
			}
			this.addClouds();
		}
		else {			
			for (let child of world.scene.children) {
				// console.log(child.type, child.name);
				if (child instanceof THREE.Group) {
				  child.traverse((subchild) => {
					if (subchild instanceof THREE.Mesh) {
					  subchild.receiveShadow = true;
					  if (!noShadowCast.includes(child.name)) {
						subchild.castShadow = true;
					  }
					  // Apply flat material to each mesh while maintaining color and shadows
					  const flatMaterial = new THREE.MeshBasicMaterial({
						color: subchild.material.color,
						shadowMap: true,
						shadowSide: THREE.DoubleSide,
					  });
					  subchild.material = flatMaterial;
					  if (!noTransparency.includes(child.name)) {
						subchild.material.transparent = true;
						subchild.material.opacity = 0.9;					
					  }
					}
				  });
				} else if (child instanceof THREE.Mesh) {
				  child.receiveShadow = true;
				  if (!noShadowCast.includes(child.name)) {
					child.castShadow = true;
				  }
				  // Apply flat material to the mesh while maintaining color and shadows
				  const flatMaterial = new THREE.MeshBasicMaterial({
					color: child.material.color,
					shadowMap: true,
					shadowSide: THREE.DoubleSide,
				  });
				  child.material = flatMaterial;
				  if (!noTransparency.includes(child.name)) {
					child.material.transparent = true;
					child.material.opacity = 0.9;
				  }
				}
			  }
		}

		// Call a function after world is loaded
		this.callback();
	};
	

	onError = (error) => alert(error);	

	
	addLights = () => {
		this.ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
		this.scene.add(this.ambientLight);

		this.sunlight = new DirectionalLight(0xffffff, 1);
		this.scene.add(this.sunlight);

		this.floorLight = new THREE.DirectionalLight(0xffffff, 0.5);
		this.floorLight.position.set(-100, -200, -100);
		this.scene.add(this.floorLight);
	};

	addClouds = () => {
		for (let i = 0; i < 30; i++) {
			const cloud = new Cloud();
			this.scene.add(cloud);
		}
	};

	addSkydome = () => {
		const skydome = new Skydome();
		this.scene.add(skydome);
	};
}

  
class Control extends _Control(THREE) {
	constructor(camera, renderer) {
		super(camera, renderer.domElement);
		
		const ACTION = _Control(THREE).ACTION;  
		this.touches.one = ACTION.TOUCH_TRUCK;
		this.touches.two = ACTION.TOUCH_DOLLY_ROTATE;
		this.touches.three = ACTION.NONE;
		this.mouseButtons.left = ACTION.TRUCK;
		this.mouseButtons.right = ACTION.ROTATE;
		this.mouseButtons.middle = ACTION.NONE;
		this.verticalDragToForward = true;
		this.maxPolarAngle = Math.PI / 2 - 0.4;
		this.draggingDampingFactor = 0.088;
		this.dollySpeed = 0.5;
		this.maxDistance = 400;
		this.minDistance = 100;
	}
  
	gotoStart() {  
		this.setLookAt.call(
			this,
			161.54554314966015, // position x
			326.9337838247367, 	// position y
			407.8612083885392, 	// position z
			-5.844098919514494, 	// target x
			8.826516847940953e-15, 	// target y
			-12.078760084756844,	// target z
			false				// transition?
		);

		setTimeout(() => {
			this.setLookAt.call(
				this,
				-122.20639101984354, 
				229.1889747943928, 
				225.44879824122293, 
				-5.844098919514494, 
				8.826516847940953e-15, 
				-12.078760084756844,
				true
			);
		}, 150);
	}
  }
  
  
  // Create the scene, camera, renderer, and control objects
  let scene, camera, renderer, control;
  scene = new Scene();
  camera = new Camera();
  renderer = new Renderer();
  control = new Control(camera, renderer);
  
  // Load the world
  const world = new World(scene, () => {
	control.gotoStart();
	control.setBoundary(world.border);

	let totalPolygonCount = 0;


	// Disable reflections for all materials
	const disableReflections = (material) => {
		material.envMap = null;
		material.metalness = 0;
		material.roughness = 1;
	};

	scene.traverse((child) => {	  
		if (child instanceof THREE.Mesh) {
			
			if (child.material instanceof THREE.Material) {
				disableReflections(child.material);
			} 
			else if (Array.isArray(child.material)) {
				child.material.forEach(disableReflections);
			}
			
			child.frustumCulled = false;
			child.matrixAutoUpdate = false;
			child.material.envMap = null;
    		child.material.needsUpdate = true; // Update the material
			child.updateMatrix();



			
			// Access the position attribute of the mesh's geometry
			const positionAttribute = child.geometry.getAttribute('position');
	
			// Get the number of vertices in the mesh's geometry
			const vertexCount = positionAttribute.count;
	
			// Calculate the number of polygons (triangles) based on the number of vertices
			const polygonCount = vertexCount / 3;
	
			totalPolygonCount += polygonCount;
		}
	});

	console.log(`Polycount: ${totalPolygonCount}`);

	renderer.shadowMap.needsUpdate = true;
  });

    
  // Set up renderer and append to the document
  renderer.render(scene, camera);
  document.getElementsByTagName('BODY')[0].appendChild(renderer.domElement);
  