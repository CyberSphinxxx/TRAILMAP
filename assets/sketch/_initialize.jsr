class Scene extends THREE.Scene {
	constructor() {
	  super();
	  this.fog = new THREE.FogExp2(0xC5C9DB, 0.0003);
	  this.background = new THREE.Color(0x87CEEB); // Blue-white sky color
	}
  }
  
  class Camera extends THREE.PerspectiveCamera {
	constructor() {
	  super(60, window.innerWidth / window.innerHeight, 0.1, 5000);
	  this.position.y = 200;
	}
  }
  
  class Renderer extends THREE.WebGLRenderer {
	constructor() {
	  super({ antialias: true });
	  this.shadowMap.enabled = true;
	  this.shadowMap.autoUpdate = false;
	  this.shadowMap.type = THREE.VSMShadowMap;
	  this.outputEncoding = THREE.sRGBEncoding;
	  this.setSize(window.innerWidth, window.innerHeight);
	  this.setPixelRatio(0.9);
	}
  }


  class DirectionalLight extends THREE.DirectionalLight {
	constructor() {
	super(0xffffff);
	this.shadow.camera.top = 500;
	this.shadow.camera.bottom = -500;
	this.shadow.camera.left = -500;
	this.shadow.camera.right = 500;
	this.shadow.camera.near = 1;
	this.shadow.camera.far = 5000;
	this.shadow.mapSize.set(1024, 1024);
	// this.shadow.bias = -0.001;
	
	this.position.set(100, 500, 600);
	this.target.position.set(0, 0, 0); // Position the target at the center of the world

	this.castShadow = true;
	this.shadow.camera.position.set(-500, 1000, -500); // Adjusted light angle

	// Create a box to visualize the shadow camera frustum
	const shadowCameraHelper = new THREE.CameraHelper(this.shadow.camera);
	this.add(shadowCameraHelper);
	}
}




class Cloud extends THREE.Object3D {
	constructor() {
	  super();
  
	  const cloudMaterial = new THREE.MeshLambertMaterial({
		color: 0xffffff,
		transparent: true,
		opacity: 0.13,
	  });
  
	  const cloudMeshes = [];
	  const numDodecahedrons = Math.floor(Math.random() * 2) + 4; // Random number of dodecahedrons (between 4 and 5)
  
	  for (let i = 0; i < numDodecahedrons; i++) {
		const x = Math.random() * 1500 - 750; // Random x position between -500 and 500
		const y = Math.random() * 150 + 130; // Random y position between 100 and 300
		const z = Math.random() * 1500 - 750; // Random z position between -500 and 500
  
		const cloudSize = Math.random() * 32 + 26; // Random size between 50 and 80
		const cloudGeometry = new THREE.DodecahedronGeometry(cloudSize, 0);
		const cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);

		cloudMesh.position.set(x, y, z);
  
		const scale = cloudSize / 50; // Adjust the scale based on the size
		cloudMesh.scale.set(scale, scale, scale);
  
		cloudMeshes.push(cloudMesh);
	  }
  
	  const cloudGroup = new THREE.Group();
	  cloudGroup.add(...cloudMeshes);
	  this.add(cloudGroup);
	}
  }
  
  



  class Skydome extends THREE.Mesh {
	constructor() {
		const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
		const skyMaterial = new THREE.ShaderMaterial({
			vertexShader: `
				varying vec3 vWorldPosition;

				void main() {
					vec4 worldPosition = modelMatrix * vec4(position, 1.0);
					vWorldPosition = worldPosition.xyz;
					gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				}
			`,
			fragmentShader: `
				varying vec3 vWorldPosition;

				void main() {
					float brightness = clamp(vWorldPosition.y / 1000.0, 0.0, 1.0);
					
					// Calculate the gradient based on the vertical position
					float gradient = clamp((vWorldPosition.y + 500.0) / 1000.0, 0.0, 1.0);
					
					// Interpolate between a lighter blue and the bottom blue using the gradient
					vec3 topColor = vec3(0.8, 0.9, 1.0); // Lighter blue color
					vec3 bottomColor = vec3(0.53, 0.81, 0.92); // Bottom blue color
					vec3 skyColor = mix(topColor, bottomColor, gradient);

					gl_FragColor = vec4(skyColor, 1.0);
				}
			`,
			side: THREE.DoubleSide, // Disable backface culling
		});

		super(skyGeometry, skyMaterial);
	}
}







class World {
	constructor(scene, callback) {
		this.scene = scene;
		this.callback = callback;
		new _Loader().parse(_Model, '', this.onLoad, this.onError);
		this.buildings = [];
	}

	onLoad = (world) => {
		this.scene.add(world.scene);

		world.scene.children.forEach(child => {
			if (child.name === "BLDG_44_-_Student_Center_&_Education_Complex") {
				console.log(child.name);
				child.children.forEach(subChild => {
					console.log(subChild.name);
					const originalMaterial = subChild.material;
					const modifiedMaterial = originalMaterial.clone();
					modifiedMaterial.transparent = true;
					modifiedMaterial.opacity = 0.1;
					subChild.material = modifiedMaterial;
				});
			}
			
		});

		// this.children = world.scene.children;

		const noShadowCast = ['Road', 'Pathway'];
		const noTransparency = ['Road', 'Pathway', 'Trees'];


		// for (let child of this.children) {
		// 	if (child instanceof THREE.Group) {

		// 	// 	for (let subChild of child.children) {
		// 	// 		subChild.receiveShadow = true;

		// 	// 		if (!noShadowCast.includes(child.name)) {
		// 	// 			subChild.castShadow = true;
		// 	// 		}

		// 	// 		if (!noTransparency.includes(child.name)) {
		// 	// 			subChild.material.transparent = true;

		// 	// 			if (this.buildings.indexOf(child) === -1) {
		// 	// 				this.buildings.push(child);
		// 	// 			}
		// 	// 		}
		// 	// 	}
		// 	// } else if (child instanceof THREE.Mesh) {
		// 	// 	if (child.name.substr(0, 6) === "Marker") {
		// 	// 		child.material.transparent = true;
		// 	// 		child.material.opacity = 0;
		// 	// 		continue;
		// 	// 	}

		// 	// 	child.receiveShadow = true;

		// 	// 	if (!noShadowCast.includes(child.name)) {
		// 	// 		child.castShadow = true;
		// 	// 	}

		// 	// 	if (!noTransparency.includes(child.name)) {
		// 	// 		child.material.transparent = true;
		// 	// 		child.material.opacity = 1;
		// 	// 		this.buildings.push(child);
		// 	// 	}
		// 	}
		// }

		 // Add lights, clouds, and skydome

		this.addLights();
		this.addClouds();
		this.addSkydome();

		this.callback();
	};
	

	onError = (error) => alert(error);	

	addLights = () => {
		const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
		this.scene.add(ambientLight);

		const directionalLight = new DirectionalLight(0xffffff, 1);
		this.scene.add(directionalLight);

		const floorLight = new THREE.DirectionalLight(0xffffff, 0.5);
		floorLight.position.set(-100, -200, -100);
		this.scene.add(floorLight);
	};

	addClouds = () => {
		for (let i = 0; i < 30; i++) {
			const cloud = new Cloud();
			this.scene.add(cloud);
		}
	};

	addSkydome = () => {
		const skydome = new Skydome();
		this.scene.add(skydome);
	};
}

  
  class Control extends Controller {
	constructor(camera, renderer) {
	  super(camera, renderer.domElement);
	  this.touches.one = Controller.ACTION.TOUCH_TRUCK;
	  this.touches.two = Controller.ACTION.TOUCH_DOLLY_ROTATE;
	  this.touches.three = Controller.ACTION.NONE;
	  this.mouseButtons.left = Controller.ACTION.TRUCK;
	  this.mouseButtons.right = Controller.ACTION.ROTATE;
	  this.mouseButtons.middle = Controller.ACTION.NONE;
	  this.verticalDragToForward = true;
	  this.maxPolarAngle = Math.PI / 2 - 0.4;
	  this.draggingDampingFactor = 0.08;
	  this.dollySpeed = 0.5;
	  
	//   this.setBoundary(
	// 	new THREE.Box3(
	// 	  new THREE.Vector3(-500, -500, -650),
	// 	  new THREE.Vector3(700, 0, 300)
	// 	)
	//   );

		
	}
	  
	gotoStart() {
		setTimeout(() => {
			this.setLookAt(
				-105.2412783950723,  		// position X
				39.303190217129696,  		// position Y
				96.57219887634977,   		// position Z
				-53.16178713424244, 		// target X
				-1.6820200891396718e-17, 	// target Y
				19.569377822233008, 		// target Z
				true 						// transition?
			);
		// world.changeBuildingOpacity(0.1);
		}, 1000);
	}  
  }
  
  // Create the scene, camera, renderer, and control objects
  let scene, camera, renderer, control;
  scene = new Scene();
  camera = new Camera();
  renderer = new Renderer();
  control = new Control(camera, renderer);
  
  // Load the world
  var world = new World(scene, () => {
	control.gotoStart();
	renderer.shadowMap.needsUpdate = true;
  });
  
  // Set up renderer and append to the document
  renderer.render(scene, camera);
  document.getElementsByTagName('BODY')[0].appendChild(renderer.domElement);
  